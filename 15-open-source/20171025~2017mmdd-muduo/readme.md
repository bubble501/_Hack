一直都对网络编程感兴趣，毕竟网络在我们的生活中有如此广泛的应用。所以我总是希望自己能够弄清楚网络的工作原理。加上自己在平时的工作中也很多的接触网络编程，但是自己一直没有形成一套完成的网络编程标准

其实网络编程也是有固定的套路的，比如像libevent、muduo等网络库中都是使用一些成熟的网络编程模式来实现的，最常见的就是Reactor模式；相对的，Proactor模式目前在网络库的开发中使用的其实还是比较少的

这个过程我会参考众多资料：

* 网络上众多的研究muduo源码的文章
* 陈硕的书《Linux多线程服务端编程》
* 等等

我会转抄众多的资料，也会自己跟着书上的实验自己逐步完成，在实践中深刻体会网络原理细节、网络编程细节！

我会在这个过程中尝试输出以下内容：

* 阅读muduo源码的过程中，添加详细的注解
* 跟着《Linux多线程服务端编程》将实验认真完成，并且思考和总结背后的原理
* 最终要在[www.xumenger.com](www.xumenger.com)上整理出几篇高质量的关于网络和网络编程的文章
* 熟悉C++的各种特性的用法
* 整理网络编程的套路
	* 如何规范的使用各种Socket API
	* 都说关闭连接是最难的，那应该如何优雅的关闭连接
* 整理内存管理的套路
* 整理多线程编程的套路
	* 如何安全的做到多线程同步
	* 如何保证不因为线程同步过分影响程序性能
* 思考编码的整洁度、规范方面的细节

>下面记录我阅读源码的顺序

## (20171026)阅读完examples/pingpong

首先通过这个简单的例子对muduo的API该如何使用有一个认识，为后续研究muduo内部的实现做准备！另外这个例子中有众多C++特性的使用，比如boost的广泛使用。我对于C++的诸多特性使用的还是比较少的，所以这也是一个很好的机会去更深入的了解C++

阅读和注解代码中遇到的问题：

* 对boost::bind的用法进行了梳理
* Channel这个类具体的作用是什么？
* ::socketpair()这个接口是什么作用？
* struct rlimit这个结构体是啥？
* EventLoop的实现细节和工作逻辑细节？

## (20171027)阅读examples/curl

* 对boost::function的用法进行了梳理
* 里面有用到了智能指针boost::shared_ptr
* 另外[《CURL常用命令》](http://www.cnblogs.com/gbyukg/p/3326825.html)可以了解curl
* 目前对于EventLoop、回调的逻辑弄不清楚，目前对调用逻辑不太好理解

## (20171027)阅读muduo/base/Thread

包括的源文件有：Thread.h、Thread.cc、CurrentThread.h

* 用空间换时间的小技巧：
	* 第一次调用获取线程ID的方法时，才进行系统调用获取线程ID
	* 在第一次进行系统调用获取线程ID的同时就将其以int、string分别存储到缓存
	* 后续再获取线程ID的时候可以直接从缓存中获取，而不用进行系统调用！
	* 既用int类型也用string类型是为了在需要任何一种类型的时候不必再去实时转换！
* \_\_thread关键字类似于Delphi中的threadvar，每个线程有独立的变量实体，互不干扰
	* 可以用这个关键字来定义变量来存储每个线程特定的信息
	* 比如int类型线程ID、string类型线程ID、线程名称等信息
* muduo中的Thread相关的代码主要是对pthread进行了封装！

不过在阅读代码的过程中也发现一些问题：

* pthread\_atfork的详细作用是什么
* std::move()我做了简单整理，但还不是理解的很好
* 为什么把Thread定义为单例的，明明在实际编码中可能会创建多个线程啊？！
* muduo中是如何具体使用Thread这个模块的呢？

## (20171101)阅读muduo/base/Log..

包括的源文件有：AsyncLogging.cc、AsyncLogging.h、LogFile.cc、LogFile.h、Logging.cc、Logging.h、LogStream.cc、LogStream.h

* 其实每个源文件中也没有多少代码，其如何封装、如何模块化的思路还是值得学习的
* AsyncLogging封装的是异步写日志线程，内部有一个专门写日志的异步线程
	* 其实异步写日志的实现整体和目前我们报盘组的THsWriteLog实现是一致的
	* 只是可能有一些细节有差异！
* LogStream中定义了定长的内存缓冲区、实现了日志流类（主要是重载各种类型参数的 << 操作符）
	* 一次申请定长的内存Buffer，然后重复使用
	* 这个模块中还有涉及到十进制、十六进制转换成字符串的函数实现
	* 重视各种整型：int、long、short之间的转换和兼容关系！

依然存在的一些问题点：

* AsyncLogging模块用到Mutex、Condition、CountDownLatch模块，这些暂时还没有看呢
* 很多C++中STL、boost的用法还是有点糊涂！
* 具体日志模块在muduo中是怎么使用的目前还没有看
* 目前是简单阅读完成，没有介入GDB进行单步调试，分析变量、函数

## (20171101)阅读muduo/base/BlockingQueue

涉及到的源文件：BlockingQueue.h

* 其中用到了MutexLock来进行加锁，保证队列数据的安全性
	* 这个看起来和报盘组内部封装的TMyQueue有些像
* 另外其中用到了Condition
	* 当队列为空的时候，如果去取数据，那么`notEmpty_.wait();`
	* 当往队列中放数据的时候，调用`notEmpty_.notify();`，通知wait的地方继续运行
	* 这个Condition看起来和报盘组内使用的TTaskWakeUp很像

>看到这里，发现很多基础的东西都是互通的，剩下的基础模块可以在后续阅读网络模块的时候再回头看！

## 最后需要总结的一些技术点

* C++语法层面
	* std::move的作用、原理和用法
	* boost::function
	* boost::shared_ptr
	* boost::scoped_ptr
	* std::deque
* 操作系统层面
	* 多线程
	* 线程同步
* 内存管理层面
	* 如果释放了内存地址，但还有某个地方有指针指向这个地址，如果不小心访问就会出问题！这个该怎么应对？
* 文件IO层面
* Socket API层面
	* 如何优雅地关闭TCP连接
	* 如果旧的TCP关闭了，结果代码中还有地方在用这个socket，新来的连接socket正好和老的socket重复了，那么这种场景如何应对；类似于释放了内存地址，但还有某个地方有指针指向这个地址，如果不小心访问就会出问题！
* 编码规范层面

>Windows平台使用Windbg调试用户态、内核态程序

## 简介

软件调试的过程其实就是侦察、发现、推理的过程

软件调试是一个特别的搜索问题：关键字不确定；目标空间很庞大，4GB/16TB，整个计算机系统

多核、多线程、安全性——软硬件的发展都在继续增大软件调试的难度

要想很好的理解调试，必须对计算机的软硬件有一个很好的、系统的理解
	
* CPU的调试支持：INT1、INT3，调试寄存器、陷阱标志、中断异常和分支监视
* 操作系统的调试支持：调试事件的分发和管理，用户态调试子系统、内核调试引擎
* 编译器的调试支持：调试符号、运行期检查
* 被调试软件的可调试性
* 调试器和其他调试工具的调试功能

## CPU的调试支持

软件断点：INT3指令，比如我们使用VC进行断点调试时，其实底层就是插入一个INT3指令

可以使用Windbg对可执行程序在某个地址处下软件断点

* 使用Windbg打开一个EXE文件
* bp 16进制地址，在程序的某个地址处下软件断点
* bl，列举目前所有的断点信息
* g，运行EXE程序，当遇到断点时，会暂停运行，方便调试
* u 16进制地址，可以查看该地址处的汇编指令

硬件断点，其基础是调试寄存器

陷阱标志

异常机制

需要对于常见的CPU架构、寄存器有很好的掌握才行

IA-32手册

## 操作系统的调试支持

对于Windows，需要了解像ntdll、kernel32.dll等dll的作用……

Windbg设置符号表

Windbg命令：

* ~1s：切换到1号CPU
* u 函数名：将该函数进行反汇编，得到对应的汇编指令
* !idt -a：查看中断描述符表

研究内核调试是很好的学习计算机原理的方法

用户态调试

Windbg命令：~0 k：查看0号线程的栈回回溯

64位和32位

怎么为Windbg编写调试脚本

使用Windbg追踪弹出文件打开窗口的过程

Windows/Linux的调试API

* Linux使用ptrace这个API：Attach、访问内存、断点、访问代码
* 相比于Windows，Linux对于调试在API层面的支持还是比较少的

Windows上调试进程的时候，如果对当前线程单步使当前线程停下来，那么剩下的其他线程也会被停下来，即在Windows上要停都停，要运行都运行。而在Linux上可以选择所有线程都停下来，还是只停当前被单步的那个

Windows操作系统的异常分发过程
	
* Win32异常：包括CPU异常及Windows操作系统所定义的异常
* CLR异常：CLR及.Net程序定义的异常，异常代码是0xe0434f4d，即.COM
* C++异常：代码为0xe06d7363，即.msc

## 编译器对调试的支持

编译器对调试的支持

* 生成符号文件
* Windows上的符号文件格式是PDB，其标准未公开
* Linux下的符号文件使用DWARF格式，是公开的标准
* Windows上一般是将符号文件和可执行文件分开的
* Linux上一般是将符号文件和可执行文件合在一个文件中的

PEView可以查看可执行文件

* 可执行文件中会有专门的段存储对应的PDB信息：PDB文件路径等
* 所以有必要研究一下可执行文件的格式
* WinDbg就是通过可执行文件中的PDB信息去自动找到并加载PDB文件的

SysView可以用于查看PDB文件

符号服务器

## 调试器
	
用户态调试器原理和调试事件

调试会话的建立方式

* 在调试器中启动被调试程序，被调试进程通常被创建为调试器进程的子进程
* 附加到正在运行的进程。调试DLL、调试网站的服务端代码
* 作为JIT调试器附加到崩溃的进程，这种对于排查程序崩溃问题有重大作用

WinDbg命令可以分为3类

* 常规命令：命令一般比较短，比如d\*、e\*、b\*、r\*。应用比较多，所以比较短的话会很方便
* 元命令：命令前面有一个.，比如.reboot，.reload
* 扩展命令：命令前面有一个!，比如!process，!thread

WinDbg功能强大，想要在Windows平台进行比较深入的学习的话都离不开WinDbg

没有源代码的调试
* 调试符号
* 栈回溯
* 要学习一些基础的汇编

命令提示符

* \*BUSY\*：Debugger正在运行
* 0:005>：用户态，当前的进程号和线程号
* 0:kd>：内核态，内核调试，0为CPU号
* lkd>：本地内核调试

设置路径

* .srcpath：源代码的路径
* .exepath：可执行映像的路径，在分析Dump文件时会用到
* .sympath：符号文件的路径

命令表达式，支持两种表达式

* C++表达式，默认使用10进制（0n）
* MASM表达式，默认该种表达式，默认使用16进制（0x）

控制被调试程序

* g(go)、gh(Go handled)、gn(Go not handled)、gc(Go condition)、gu(Go up，回到父函数)
* p(Step)、pa(Step to address)、pc(Step to next call)
* t(Trace)、ta(Trace to address)、tc(Trace to next call)、tb(Trace to next branch，单步到下一个分支)
* 强大的WT命令：自动追踪命令

读写内存

* d\*系列命令：读内存
* e\*系列命令：编辑内存
* 区域操作：移动m、填充f、比较c、查找s

读写寄存器
	
* ~2 r：显示线程2的寄存器
* ~\* r eax：显示所有线程的eax
* r eax=8：改变当前线程的eax
* r zf：显示标志寄存器的zf
* r eax = @ebx：将EBX的值赋给EAX

使用断点
	
* 软件断点
	* bp：设置断点，bp ntdll!RtlRaiseException "r eax; dt MyVar; g"
	* bu：设置延迟的断点
	* bm：模式匹配，bm /a nt!Dbgk\*
* 硬件断点：ba i|w|r|en 地址
* 控制和显示：be、bd、bl、bc

使用WinDbg挖地雷，使用调试器把雷的个数改成0。eip寄存器

远程调试

* 调试器与被调试程序位于两台不同的机器上，通过网络连接通信
* 当然需要在远程机器上先开启WinDbg，相当于在本机操作远程的WinDbg
* 比如可以通过远程调试排查客户现场的崩溃问题
* 很有意思，也很有用，可以针对性的整理一篇文章

## 软件的可调试性

提高软件的可调试性，是软件团队中所有人的职责

* 架构师规划
* 程序员建造
* 测试人员

典型技术

* 消息输出：print、日志
* 转储：产生Dump
* 轨迹记录：记录栈回溯、分支监控和记录
* 自动报告：将收集的信息远程发回来
* 辅助诊断

WPA可以录制整个操作系统的CPU占用、内存、磁盘IO等信息，然后输出报告
	
* 因为是录制整个系统，所以也就包含每个运行的进程，正好也可以用于分析某个具体的程序
* 根据输出的报告去分析程序的问题所在
* 很明显是一个很好的分析程序的工具！
* 值得花时间好好研究！
* 比如分析CPU占用问题，可以在程序运行时打开WPA进行录制，然后使用WPA自动分析，最终基本可以定位具体的线程、函数，然后再去针对性的分析有问题的函数
* 在我的机器上安装WPA：Windows Performance Recoder

转储

* 对象转储，对某个内存对象的状态（属性值）进行转储，MFC的对象有Dump方法
* 应用程序转储
* 系统转储，蓝屏崩溃时，Windows会自动做

## 栈调试

了解Windows进程的内存结构，重点了解栈内存结构，尤其是栈的增长方向

用户态栈的缺省保留地址空间是1MB

* 每个线程有自己的用户态栈
* 函数局部变量、参数等都会放在栈上，所以为了防止栈溢出，需要考虑别使用较大的局部变量、参数

从栈上分配空间意味着栈指针向更低的地址移动，腾出更多空间

当前的栈内存被全部用完后，就会报一个栈溢出异常

栈帧

* 供一个函数使用的一块连续栈区域
* 父函数在下方，子函数在上方
* 函数返回时即释放

x86如何索引栈帧

* 帧指针EBP，32位的情况：
	* 浮动栈上的稳定参照物
	* \*EBP = 父函数的EBP
	* \*(EBP+4) = 函数返回值
	* \*(EBP+8) = 栈上的第一个参数
	* \*(EBP+C) = 栈上的第二个参数
	* ……
	* 这是针对Debug版本
* ESP寄存器，32位的情况
	* 优化措施
	* 不利于调试
	* 使用Release编译，可能开启FPO优化
	* 目前不推荐打开FPO优化

对于函数调用的汇编指令充分了解后，会很好的帮助了解栈的工作原理
	
* 在接下来学习汇编语言的时候，专门针对函数调用的汇编进行学习
* 整理一篇技术博客，分析函数调用时每条汇编指令的作用，以深入了解汇编、了解栈工作机制

以上主要讲的32位的情况，64位有很多不同

缓冲区溢出

* X86架构中，栈是向低地址方向增长的
* 向缓冲区写入超过其容量的内容可以覆盖栈上的函数返回地址，使函数返回到意外的地方
* 栈溢出攻击，因为函数指令也是01模式的，可以将一些有问题的指令传给程序，同时使其栈溢出，然后运行这段精心设计的有问题的代码指令。比如通过覆盖栈数据使程序运行到一个死循环逻辑中

基于Cookie的安全检查

* 在栈帧的起始处存放一个整数：Cookie
* 函数返回时检查Cookie的完整性，如果损坏则报告
* 一个小技巧解决了很严重的安全问题
* Visual Studio编译时指定/GS选项即可启用

编译器的运行期检查包括：
	
* Run-Time Error Check	
* 栈指针被破坏
* 局部缓冲区（数组）越界
* 栈被破坏
* 依赖未初始化过的局部变量
* 因为赋值给较短的变量导致数据丢失
* 观察栈帧，布局，Cookie

钻研方向

* 用WinDbg来调试分析WinDbg，以了解WinDbg的原理
* 阅读Visual Studio的源码
* 熟悉CPU架构
* 熟悉Windows、Linux内核

对于计算机相关的时间没有概念

* CPU切换一次线程花的时间是什么量级
* CPU执行一条指令花的时间是什么量级
* 进程从磁盘中读写1KB数据花的时间是什么量级

安全编程最需要注意的：不相信函数参数传入的内容，所以最好是在函数入口就对入参进行安全性检查

可以在操作系统上设置（DEP）不执行数据段的代码
	
* 只执行代码段的代码
* 这样一些黑客放到数据段的代码，想通过栈溢出运行数据段的供给代码就不会得逞

## 堆调试

Windows内存管理
	
* 应用程序
* CRT堆
* Win32堆
* 内核池
* 内存管理器

堆管理器

Win32堆
	
* 实现在NTDLL.DLL中的通用堆管理器
* 目的是为用户态的应用程序提供内存服务，通常被称为Win32堆管理器
* SDK中公开了一组API来访问Win32堆管理器的功能，如HeapAlloc、HeapFree等
* 创建一个新进程时，系统会为每个进程创建进程的默认堆--GetProcessHeap()返回的就是这个堆

!heap 进程堆的句柄值 (-a)

* 查看堆信息
* 进程堆的句柄值也是堆的基地址

!peb可以查看进程环境块

堆的调试支持
	
* 堆尾检查
* 释放检查
* 参数检查，对传递给堆管理器的参数进行更多的检查
* 调用时验证
* 堆块标记
* 用户态栈回溯

页堆

* 专门用于调试
* 大量使用内存页——为了调试，不惜代价
* 对调试堆溢出特别有效，实时中断到调试器

C运行库的内存检查
	
* 编译器的调试支持
* 调试版本使用调试堆，调试版本的分配函数，分配时记录额外的分配信息

Win32堆和CRT堆的常用字节模式和它们的含义

做一个堆分配的小demo
* 在VC、Visual Studio中一直跟踪
* 看编译器内部的代码实现
* 了解编译器是如何处理用户代码层面的堆分配的，以及研究编译器的编码风格

编译器启动内存泄漏检查的逻辑是如何实现的，依赖的底层原理是什么

其实内存中一层一层的堆，用户堆、CRT堆、Win32堆……

* 其也是一层一层的，每一层也有特定的格式
* 其实和网络的层次结构、网络协议的二进制规范很相似的
* 用这样的思路可以看到在计算机设计中层次的改变、协议的应用是很广泛的

WinDbg的内存有关内核调试命令

* !pte	页表表项
* !pool	内核池
* !vm		虚拟内存使用情况
* !memusage	物理内存使用情况

UMDH分析内存分配

Application Verifier工具
	
* 很好的在开发阶段分析程序内存使用等信息的工具
* 有必要安装并好好研究

关于软件调试、计算机组成原理实在是还有太多需要深刻研究的

## 多线程调试

线程
	
* CPU的调度单位
* 任务
* 任务状态段

进程

* 线程的住所
* OS组织和管理程序的重要单位

建议阅读CPU手册

进程数据结构，!peb 命令可以查看进程数据结构的值

线程数据结构
	
* !teb 命令可以查看线程数据结构的值
* GetLastError其实就是获取线程数据结构中的某个字段值
* 可以对GetLastError进行反汇编查看
* x kernelbase!\*getlasrerror	获取GetLastError函数地址
* u 函数地址					对其进行反汇编，了解函数内部逻辑

操作系统内部实现就是
	
* 使用进程数据结构管理进程
* 使用线程数据结构管理线程
* 所以以这个为切入点可以很好的了解操作系统的内部实现原理

线程上下文，就是\_CONTEXT这个结构体

* dt \_CONTEXT 命令可以输出当前线程上下文信息
* 这个结构体专门用于保存寄存器状态信息的
* 用户态可以通过GetThreadContext和SetThreadContext查看和修改线程上下文信息

以上的简单讲解已经让我初步了解操作系统是如何表示进程、线程的了

* 但还是很初步
* 其更深入的原理，和CPU是怎么配合的还是不清楚

控制进程和线程

* | 显示进程信息；|s 设置当前线程
* ~ 显示线程信息；~s设置当前线程

控制线程
	
* ~n 挂起，~m 恢复挂起，改变线程的挂起计数，相当于调用SuspendThread和ResumeThread
* ~f 冻结，~u 解冻，调试子系统的控制，脱离调试时会自动解冻

针对线程执行命令
	
* ~\*k	针对所有线程执行k命令查看所有线程的栈回溯信息
* ~\*e !gle 依次显示所有线程的Last Error
* ~\*e ? $tid;.ttime

同时调试几个进程
	
* .attach		附加到其他进程，.attach 0n5896
* .create		创建新的被调试进程，.create notepad.exe
* | 查看当前同时被调试的多个进程
* | 1s 将被调试的进程切换为1号进程（这个序号不是操作系统层面的，而是WinDbg定义的号）

临界区
	
* 使用CRITICAL\_SECTION结构来保证不会有多个线程重入被保护的代码段
* 实现在用户态的同步机制，相对于内核对象来说，开销更小
* 只能用于同步同一进程内的多个线程

临界区工作原理
	
* LockCount字段，初始值为-1，被线程拥有后，大于等于0，反映等待和已经进入关键区的线程数
* OwningThread字段，拥有线程（已经进入临界区）的句柄
* LockSemphore字段，唤醒等待的线程
* 重点了解操作系统是如何定义的临界区结构体的，每个字段的含义和作用

临界区的调试支持
	
* 在初始化临界区结构时，系统会分配一个RTL\_CRITICAL\_SECTION_DEBUG结构
* 每个临界区的调试结构依靠ProcessLocksList字段相互联系在一起

dt \_RTL\_CRITICAL\_SECTION 0x00418924，该命令可以查看某个临界区信息

挂死

* 死锁
	* 多线程参与
	* 互相等待，无法解脱
	* 昏死状态CPU占用率低
* 死循环
	* 陷入无限循环
	* CPU狂转，热
	* 风扇狂转
* 软件的复杂性

硬件加锁，CPU支持通过汇编层面的加锁

## 内核调试

一个程序员永远不应该写超出他所能控制的复杂度的程序。软件工程师的控制力体现在：知识、工具

迪杰斯特拉的笔记：EWD Note

Windows的哲学

* 尽可能复杂
* 然后通过一个强大的调试器来平衡复杂度

Linux的哲学
	
* 不喜欢调试器
* 然后通过将代码写好、写简单来平衡

如何探索NT内核

* 最宝贵的资源：调试符号
	* 微软公开了几乎所有内核文件的调试符号PDB，内部包含了丰富的函数名、结构定义等内部实现信息
* 最有效的方法：内核调试
	* 调试跟踪是了解软件的最有力武器
	* 比阅读源码的效果更好！！而且Windows内核的软件有5000万行之多，就算有代码又该怎么读呢

内核调试支持
	
* 串口
* USB 2.0
* 1394
* 网络
* USB 3.0

KD的部分全局变量
	
* KdPitchDebugger：布尔类型，是否显式抑制内核调试，当启动选项中包含/NODEBU选项时为真
* KdDebugRoutine：函数指针类型，用来记录内核调试引擎的异常处理回调函数，当内核调试引擎活动时，它指向KdpTrap函数，否则指向KdpStub函数
* KdpBreakpointTable：结构数组类型，用来记录代码断点，每个元素为一个BREAKPOINT\_ENTRY结构，用来描述一个断点，包括断点地址
* KdAutoEnableOnEvent：布尔类型，如果调试设置中的启动策略为AUTOENABLE，则设为真
* KdIgnoreUmExceptions：布尔类型，代表了处理用户态异常的方式，如果调试设置中的启动策略包含/noumex，则设置为真，含义是忽略用户态异常

KD是很成功的调试引擎，KD的变体

* Boot Debugger，简称BD
* BD in BootMgr：用于调试启动管理器
* ……

KPRCB是Windows管理CPU用到的核心数据结构
	
* 每个CPU有自己的KPRCB结构体变量
* 可以查看CPU当前运行的线程是哪一个，接下来的线程是哪一个等信息，了解CPU线程排队信息
* dt nt!\_KPRCB 可以查看值

内核版本：Checked版本和Free版本，另外还有Debug、Release版本

双机用户态调试

* 用户态调试大多时候只需要一台机器，调试器和被调试进程运行在一个操作系统中
* 但对于某些特殊的进程，如果它们被中断，那么系统便无法正常工作，此时需要让调试器运行在另一台机器上
* 比如Windows子系统的服务器进程CSRSS，一旦被中断，那么窗口便停止响应

访问用户态需要注意

* 用户空间是重叠的
* .process /i <EPROCESS>
* .process /p <EPROCESS>
* bp /p <EPROCESS> <addr>

## 高级调试技巧

处理调试事件

* 对于不同的调试事件，调试器通常有可以配置的不同处理方法
* 对于异常，调试器会最多得到两轮处理机会
	* 第一轮机会，默认不处理，返回DBG\_EXCEPTION\_NOT\_HANDLED，让系统继续分发
	* 第二轮机会，默认声明处理，返回DBG\_CONTINUE，让系统返回到发生异常的位置继续执行

自动启动调试器

* 应用场合：调试目标是以某种方式自动启动的，如果使用手工方式附加调试器，已经错过调试点活着目标已经自动退出
* 举例：VC的链接器link.exe是由所谓的driver部件自动启动的，很快自动退出
* 通过修改注册表可以实现

调用函数

* WinDbg的.call命令用来调用函数，支持用户态调试
* 在栈上插入一小段代码
* 在栈上模拟栈帧，压入参数和返回地址
* 需要私有符号

怎么为WinDbg编写调试脚本，比如编写脚本用于跟踪进程

* Windbg命令程序类似于批处理程序和脚本程序
* 类似C语言的流程控制符号
	* 分支：.if .else .elseif
	* 循环：.do .while !for\_each\_local等
	* 捕获异常.catch
	* 定义代码块.block
* 可以使用变量
	* 自动的伪寄存器，$ip
	* 用户赋值的伪寄存器，$t0~$t19
	* 用户定义的别名（as 命令）

修改代码（在汇编层面进行修改）

* 在调试器中使用汇编命令修改程序：a [address]
* 常用的指令
	* INT 3：断点
	* NOP：补位或者覆盖掉不需要的指令
	* ADD ESP, 4H：调整栈指针
	* SUB ESP, 4H：调整栈指针
	* call AcsVio!printf：调用函数

系统服务概览（Vista前后有所不同）

* System services，NT Service， or Service
* 通常没有图像界面，运行在后台，不与用户交互，除非登记Interactive属性
* 由系统的服务管理进程（services.exe）统一管理：启动、停止、事件交互
* 通过CreateService API注册，ChangeServiceConfig或ChangeServiceConfig2配置
* RegisterServiceCtrlHandler注册事件处理函数

>持续学习，持续实践
